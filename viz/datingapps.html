<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
<script src="https://d3js.org/d3.v7.min.js"></script>
<style>
:root{
    --ink:#8f304e;
    --muted:#a34b65;
    --grid:#e5e7eb;
  }

  *{box-sizing:border-box}
html,body{height:100%}

  body {
    font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    background: transparent;
    color: var(--ink);
    margin: 0;
    padding: 0;
    height: 100%;
    display: flex;
    flex-direction: column;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
  }

  .viz-root{
    max-width: 1500px;
    margin: 0 auto;
    width: 100%;
    padding: 12px 16px 16px;
    display: flex;
    flex-direction: row;
    gap: 20px;
    min-height: 0;
    height: 100%;
  }

  .chart-container {
    flex: 1;
    display: flex;
    justify-content: center;
    align-items: center;
    position: relative;
    min-height: 0;
    padding-top: 0;
  }

  svg {
    width: 100%;
    height: 100%;
  }

  .app-label {
    font-size: clamp(12px, 1.4vw + 0.7vh, 16px);
    font-weight: 600;
    text-anchor: middle;
  }

  .app-value {
    font-size: clamp(11px, 1.2vw + 0.6vh, 14px);
    font-weight: 500;
    fill: var(--muted);
    text-anchor: middle;
  }

  .dots-container {
    text-anchor: middle;
  }

  .dot {
    opacity: 0.8;
  }

  .legend-wrap {
    display: flex;
    flex-direction: column;
    gap: clamp(4px, 0.8vh, 8px);
    align-items: flex-start;
    padding: clamp(6px, 1vh, 12px) 0;
    width: 240px;
    flex-shrink: 0;
    max-height: 100%;
    overflow: hidden; /* Changed from auto to hidden to prevent scrolling */
    justify-content: flex-start;
  }

  .legend-title {
    font-size: clamp(11px, 1.2vw + 0.6vh, 15px);
    font-weight: 600;
    color: var(--ink);
    margin-bottom: clamp(4px, 0.6vh, 6px);
  }

  .legend {
    display: flex;
    flex-direction: column;
    gap: clamp(3px, 0.5vh, 6px);
    width: 100%;
    flex: 1 1 auto;
    min-height: 0;
    overflow: hidden;
  }

  .legend-toggle {
    padding: clamp(4px, 0.6vh, 6px) clamp(8px, 1vw, 12px);
    border: 2px solid var(--muted);
    background: transparent;
    color: var(--muted);
    border-radius: 20px;
    cursor: pointer;
    font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    font-size: clamp(10px, 1.1vw + 0.55vh, 13px);
    transition: all 0.2s ease;
    width: 100%;
    text-align: left;
    line-height: 1.2;
    flex-shrink: 0;
  }

  .legend-toggle:hover {
    background: rgba(163, 75, 101, 0.1);
  }

  .legend-toggle.active {
    background: var(--ink);
    color: white;
    border-color: var(--ink);
  }

  .legend-explanation {
    display: flex;
    align-items: center;
    gap: clamp(4px, 0.6vw, 8px);
    margin-top: auto; /* Push to bottom, right after toggles */
    padding-top: clamp(4px, 0.6vh, 6px);
    border-top: 1px solid var(--ink);
    font-size: clamp(9px, 1vw + 0.5vh, 12px);
    color: var(--muted);
    flex-shrink: 0;
    line-height: 1.3;
  }

  .legend-disclaimer {
    margin-top: clamp(2px, 0.4vh, 4px);
    padding-top: clamp(2px, 0.4vh, 4px);
    font-size: clamp(8px, 0.9vw + 0.45vh, 11px);
    color: var(--muted);
    font-style: italic;
    flex-shrink: 0;
    line-height: 1.3;
  }

  .summary-message {
    font-size: clamp(11px, 1.2vw + 0.6vh, 14px);
    font-weight: 600;
    color: var(--ink);
    text-align: left;
    line-height: 1.3;
    margin-bottom: clamp(4px, 0.6vh, 6px);
    width: 100%;
    flex-shrink: 0;
    min-height: calc(1.3em * 3); /* Reserve space for 3 lines to prevent layout jumping */
  }

  .legend-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background: var(--muted);
    flex-shrink: 0;
  }

  .intro{
    max-width: none;
    margin: 0 auto 20px;
    text-align: center;
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  .intro h2{
    margin: 0;
    font-size: clamp(2.1rem, 3.4vw + 1.5vh, 2.8rem);
    font-weight: 650;
    color: var(--ink);
    letter-spacing: 0.4px;
  }

  .intro p{
    margin: 0;
    font-size: clamp(14px, 1.8vw + 0.9vh, 20px);
    color: var(--muted);
  }
</style>
</head>
<body>
  <div class="intro">
    <h2>So... who's swiping where?</h2>
    <p>Toggle dating app popularity by age group and sexuality.</p>
  </div>
  <div class="viz-root">
    <div class="legend-wrap">
      <div class="summary-message" id="summary-message"></div>
      <div class="legend" id="legend"></div>
      <div class="legend-explanation">
        <div class="legend-dot"></div>
        <span>1 dot = 1% of toggled population use this app</span>
      </div>
      <div class="legend-disclaimer">
        Percentages exceed 100% because users can use multiple apps.
      </div>
    </div>
    <div class="chart-container">
      <svg id="chart"></svg>
    </div>
  </div>

<script>
d3.csv("../data/datingapps.csv").then(data => {
  // Parse data
  const apps = Object.keys(data[0]).filter(key => key !== "Group");
  const groups = data.map(d => d.Group);
  
  // Create color scale for apps using brand colors
  const brandColors = {
    "Tinder": "#FF4458",      // Tinder red/pink
    "Match": "#0066CC",        // Match blue
    "Bumble": "#CCAA00",       // Bumble darker yellow
    "OkCupid": "#3D5A80",      // OkCupid blue-gray
    "eHarmony": "#00A86B",     // Eharmony green
    "Hinge": "#FF6B9D",        // Hinge pink/rose
    "Grindr": "#FF8C00",       // Grindr orange
    "HER": "#C2185B",          // HER pink/purple
    "Other": "#555555"         // Dark gray
  };
  
  const colorScale = d3.scaleOrdinal()
    .domain(apps)
    .range(apps.map(app => brandColors[app] || "#999999"));
  
  // Create data structure
  const dataByGroup = {};
  groups.forEach(group => {
    dataByGroup[group] = {};
    apps.forEach(app => {
      dataByGroup[group][app] = +data.find(d => d.Group === group)[app];
    });
  });

  // Set up SVG
  const container = d3.select(".chart-container");
  const containerRect = container.node().getBoundingClientRect();
  const width = containerRect.width;
  const height = containerRect.height;
  const centerX = width / 2;
  const centerY = height / 2;
  const radius = Math.min(width, height) * 0.42; // Outer circle for app names
  const dotRadius = Math.min(width, height) * 0.25; // Inner circle for dots (smaller)

  const svg = d3.select("#chart")
    .attr("width", width)
    .attr("height", height);

  // Create groups for each app
  const angleStep = (2 * Math.PI) / apps.length;
  let currentGroup = "All";
  let dots = [];
  let simulation = null;
  let jitterInterval = null;

  // Calculate app positions
  const appPositions = apps.map((app, i) => {
    const angle = (i * angleStep) - (Math.PI / 2); // Start from top
    return {
      app: app,
      x: centerX + radius * Math.cos(angle),
      y: centerY + radius * Math.sin(angle),
      angle: angle
    };
  });

  // Create app labels (static)
  const appGroups = svg.selectAll(".app-group")
    .data(appPositions)
    .enter()
    .append("g")
    .attr("class", "app-group")
    .attr("transform", d => `translate(${d.x}, ${d.y})`);

  appGroups.append("text")
    .attr("class", "app-label")
    .attr("y", -10)
    .text(d => d.app)
    .attr("fill", d => colorScale(d.app));

  appGroups.append("text")
    .attr("class", "app-value")
    .attr("y", 8)
    .attr("data-app", d => d.app);

  // Custom summary messages for each group
  const summaryMessages = {
    "All": "Dating apps are widely used across all demographics. Toggle by group below.",
    "Ages 18-29": "Tinder, Hinge, and Bumble are overwhelmingly popular among 18-29 year olds.",
    "Ages 30-49": "Match and eHarmony are more popular among 30-49 year olds.",
    "Ages 50-64": "Match and eHarmony dominate among users 50-64.",
    "Ages 65+": "Match and eHarmony are most popular among users 65 and older.",
    "LGB": "Grindr and Tinder are popular among LGB users.",
    "Straight": "Tinder, Match, and Bumble are most popular among straight users."
  };

  function colorizeAppNames(text, colorScale) {
    // List of app names to look for (in order of length to match longer names first)
    const appNames = ["eHarmony", "OkCupid", "Grindr", "Tinder", "Match", "Bumble", "Hinge", "HER", "Other"];
    
    let result = text;
    appNames.forEach(appName => {
      // Create a regex that matches the app name as a whole word (case-insensitive)
      const regex = new RegExp(`\\b${appName.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
      const color = colorScale(appName);
      result = result.replace(regex, (match) => {
        return `<span style="color: ${color}; font-weight: 700;">${match}</span>`;
      });
    });
    return result;
  }

  function updateVisualization(group) {
    console.log("updateVisualization called with group:", group);
    currentGroup = group;
    
    // If Harvard data not loaded yet, wait for it
    if (group === "Harvard" && !dataByGroup["Harvard"]) {
      console.log("Harvard data not loaded yet, waiting...");
      // Data will be loaded asynchronously, will update when ready
      return;
    }
    
    if (!dataByGroup[group]) {
      console.error("Group not found in dataByGroup:", group, "Available groups:", Object.keys(dataByGroup));
      return;
    }
    
    const values = dataByGroup[group];
    console.log("Values for", group, ":", values);
    
    // Update summary message with colored app names
    const summaryElement = document.getElementById("summary-message");
    if (summaryElement) {
      const message = summaryMessages[group] || "";
      summaryElement.innerHTML = colorizeAppNames(message, colorScale);
    }

    // Update percentage values under each app name
    svg.selectAll(".app-group")
      .select(".app-value")
      .text(d => {
        const value = values[d.app] || 0;
        return value + "%";
      });

    // Stop any existing simulation and interval
    if (simulation) {
      simulation.stop();
    }
    if (jitterInterval) {
      clearInterval(jitterInterval);
      jitterInterval = null;
    }

    // Check if we have existing dots to transition from
    const existingDots = svg.selectAll(".dot");
    const hasExistingDots = existingDots.size() > 0;

    // Remove all existing dots and create new ones instantly
    svg.selectAll(".dot").remove();
    createDotsAtCenter(group, !hasExistingDots);
    
    // Update toggle button states - deselect all, then select the active one
    legend.selectAll(".legend-toggle").classed("active", function() {
      return d3.select(this).text() === group;
    });
  }
  
  // Expose functions for parent window
  window.updateVisualization = updateVisualization;
  window.getCurrentGroup = () => currentGroup;


  function createDotsAtCenter(group, isInitial = false) {
    const values = dataByGroup[group];
    dots = [];

    // Create dots data grouped by app
    const dotsByApp = {};
    appPositions.forEach((pos, i) => {
      const app = pos.app;
      const value = values[app] || 0;
      dotsByApp[app] = [];
      
      const dotAngle = pos.angle;
      const dotTargetX = centerX + dotRadius * Math.cos(dotAngle);
      const dotTargetY = centerY + dotRadius * Math.sin(dotAngle);
      
      for (let j = 0; j < value; j++) {
        dotsByApp[app].push({
          app: app,
          appIndex: i,
          targetX: dotTargetX,
          targetY: dotTargetY,
          targetAngle: dotAngle,
          x: centerX,
          y: centerY,
          vx: 0,
          vy: 0
        });
      }
    });

    Object.values(dotsByApp).forEach(appDots => {
      dots.push(...appDots);
    });

    // Calculate final positions for each dot in a beeswarm pattern
    const appGroups = {};
    dots.forEach(d => {
      if (!appGroups[d.app]) appGroups[d.app] = [];
      appGroups[d.app].push(d);
    });

    // Calculate final positions for each app's dots
    Object.values(appGroups).forEach(appDots => {
      const clusterCenterX = appDots[0].targetX;
      const clusterCenterY = appDots[0].targetY;
      
      // Arrange dots in a tight circular cluster (beeswarm pattern)
      appDots.forEach((d, i) => {
        // Arrange in concentric circles
        const ring = Math.floor(Math.sqrt(i));
        const dotsInRing = ring * 2 + 1;
        const angleInRing = (i - ring * ring) / dotsInRing * 2 * Math.PI;
        const radiusInRing = ring * 4.5; // Tight spacing - dots touching
        
        d.finalX = clusterCenterX + Math.cos(angleInRing) * radiusInRing;
        d.finalY = clusterCenterY + Math.sin(angleInRing) * radiusInRing;
      });
    });

    // Create dots at their final positions instantly
    const dotElements = svg.selectAll(".dot")
      .data(dots)
      .enter()
      .append("circle")
      .attr("class", "dot")
      .attr("r", 4)
      .attr("cx", d => {
        d.x = d.finalX;
        return d.finalX;
      })
      .attr("cy", d => {
        d.y = d.finalY;
        return d.finalY;
      })
      .attr("fill", d => colorScale(d.app))
      .style("opacity", 0.8);

    // Start subtle jitter simulation
    startJitterSimulation(dotElements);
  }

  function startJitterSimulation(dotElements) {
    // Stop any existing simulation and interval
    if (simulation) {
      simulation.stop();
    }
    if (jitterInterval) {
      clearInterval(jitterInterval);
    }

    // Create a subtle force simulation for gentle jitter
    simulation = d3.forceSimulation(dots)
      .force("x", d3.forceX(d => d.finalX).strength(0.3)) // Weak pull back to target X
      .force("y", d3.forceY(d => d.finalY).strength(0.3)) // Weak pull back to target Y
      .force("collision", d3.forceCollide().radius(4.5).strength(0.5)) // Prevent overlapping
      .force("jitter", function(alpha) {
        // Add subtle random jitter
        dots.forEach(d => {
          const jitterX = (Math.random() - 0.5) * 2; // Small random movement
          const jitterY = (Math.random() - 0.5) * 2;
          d.vx += jitterX * alpha * 0.1; // Very weak jitter force
          d.vy += jitterY * alpha * 0.1;
        });
      })
      .alphaDecay(0.02) // Slow decay to keep it running
      .velocityDecay(0.4) // Some friction
      .on("tick", () => {
        dotElements
          .attr("cx", d => d.x)
          .attr("cy", d => d.y);
      });

    // Keep simulation running by periodically restarting alpha
    jitterInterval = setInterval(() => {
      if (simulation) {
        simulation.alpha(0.3); // Restart with low alpha for subtle movement
      }
    }, 2000);
  }


  // Create legend toggles
  const legend = d3.select("#legend");
  
  groups.forEach(group => {
    const button = legend.append("button")
      .attr("class", "legend-toggle")
      .classed("active", group === "All")
      .text(group)
      .on("click", function() {
        // Remove active class from all buttons
        legend.selectAll(".legend-toggle").classed("active", false);
        // Add active class to clicked button
        d3.select(this).classed("active", true);
        // Update visualization
        updateVisualization(group);
        // Notify parent window that a toggle was clicked (so button text can update)
        if (window.parent) {
          window.parent.postMessage({ type: "groupChanged", group: group }, "*");
        }
      });
  });

  // ---- HARVARD DATA ------------------------------------------------
  // Load Harvard data and add it as a group option (like other toggles)
  d3.csv("../data/HarvardData.csv").then(raw => {
    // Parse Q9 column - it contains comma-separated app names
    const appCounts = {};
    let totalResponses = 0;

    raw.forEach(row => {
      const q9Value = row.Q9;
      if (q9Value && q9Value.trim() !== "") {
        totalResponses++;
        // Split by comma and trim each app name
        const apps = q9Value.split(",").map(app => app.trim());
        apps.forEach(app => {
          if (app && app.trim() !== "") {
            // Normalize app names to match our app list
            const normalizedApp = normalizeAppName(app);
            if (normalizedApp) {
              appCounts[normalizedApp] = (appCounts[normalizedApp] || 0) + 1;
            }
          }
        });
      }
    });

    // Calculate percentages and add to dataByGroup (like other groups)
    dataByGroup["Harvard"] = {};
    apps.forEach(app => {
      const count = appCounts[app] || 0;
      dataByGroup["Harvard"][app] = Math.round((count / totalResponses) * 100);
    });

    // Add Harvard summary message
    summaryMessages["Harvard"] = "Harvard students who use dating apps overwhelmingly use Tinder and Hinge.";
    
    // If currently showing Harvard, update the visualization
    if (currentGroup === "Harvard") {
      updateVisualization("Harvard");
    }
  }).catch(err => {
    console.error("Error loading Harvard data:", err);
  });
  
  // Listen for messages from parent window
  window.addEventListener("message", (event) => {
    if (event.data && event.data.type === "selectGroup") {
      updateVisualization(event.data.group);
    }
  });

  function normalizeAppName(appName) {
    const lower = appName.toLowerCase();
    // Map variations to our app names
    if (lower.includes("tinder")) return "Tinder";
    if (lower.includes("match")) return "Match";
    if (lower.includes("bumble")) return "Bumble";
    if (lower.includes("okcupid") || lower.includes("ok cupid")) return "OkCupid";
    if (lower.includes("eharmony") || lower.includes("e-harmony")) return "eHarmony";
    if (lower.includes("hinge")) return "Hinge";
    if (lower.includes("grindr")) return "Grindr";
    if (lower.includes("her")) return "HER";
    return "Other";
  }


  // Initialize with All (this will also set the initial percentage values)
  updateVisualization("All");
});
</script>
</body>
</html>

