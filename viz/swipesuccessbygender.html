<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Dating App Visualization</title>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/7.8.5/d3.min.js"></script>

  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
      background: transparent;
      overflow: hidden;
    }

    /* Wrapper that fills the card and scales the content uniformly */
    .viz-scale-wrapper {
      width: 100%;
      height: 100%;
      position: relative;
      overflow: visible; /* Allow content to be visible even if it extends */
    }

    /* Base logical size - everything inside scales together */
    /* Aspect ratio matches card: 1600/910 = 1.758241758... */
    .viz-root {
      width: 1200px;
      height: 682.5px; /* 1200 / (1600/910) = 682.5 to match exact card aspect ratio */
      transform-origin: center center;
      box-sizing: border-box;
      display: flex;
      flex-direction: column;
    }

    #container {
      width: 100%;
      flex: 1;
      min-height: 0;
      background: transparent;
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 0;
      box-sizing: border-box;
      overflow: hidden;
    }

    #visualization {
      width: 100%;
      height: 100%;
      display: block;
    }
    .phone { fill: #8f304e; stroke: #8f304e; stroke-width: 2; }
    .phone-female { fill: #8f304e; stroke: #8f304e; stroke-width: 2; }
    .phone-male { fill: #884b6b; stroke: #884b6b; stroke-width: 2; }
    .screen { fill: #fff5f7; stroke: #8f304e; stroke-width: 1; }
    .dynamic-island { fill: #8f304e; }
    .profile-circle { opacity: 1; }
    .button { stroke: #666; stroke-width: 2; transition: all 0.3s ease; }
    .button.pressed { transform: scale(0.9); }
    .dislike-btn { fill: none; stroke: #ff4757; stroke-width: 3; transition: all 0.3s ease; }
    .dislike-btn.pressed { fill: #ff4757; fill-opacity: 0.3; }
    .like-btn { fill: none; stroke: #2ed573; stroke-width: 3; transition: all 0.3s ease; }
    .like-btn.pressed { 
      transform: translate(12px, -25px) scale(0.9);
      fill: #2ed573; fill-opacity: 0.3; 
    }
    .male-like { transform-box: fill-box; transform-origin: center; }
    .male-like.pressed {
      transform: translate(12px, -25px) scale(0.9);
      fill: #2ed573; fill-opacity: 0.3; stroke: #2ed573;
    }
    .hand-box { fill: #ffe4c4; stroke: #333; stroke-width: 2; opacity: 0.8; }
    .dot { stroke: none; }
    .likes { fill: #06b050; }
    .dislikes { fill: #ff4757; }
    .matches { fill: #ff6b81; }
    .title { font-size: 28px; font-weight: bold; fill: #8f304e; }
    .subtitle { font-size: 16px; fill: #8f304e; }
    .label { font-size: 14px; fill: #8f304e; font-weight: 500; }
    .count { font-size: 20px; fill: #8f304e; }
    .gender-label { font-size: 22px; font-weight: bold; fill: #8f304e; }
    .vs-text { font-size: 20px; fill: #8f304e; font-style: italic; }

    /* Swipe card visuals & motion */
    .swipe-card { transform-box: fill-box; transform-origin: center; }
    .swipe-card .card-rect { fill: #ffffff; stroke: #999; stroke-width: 1.5; rx: 10; }
    .swipe-card .card-avatar { opacity: 1; }

    /* Tints */
    .tint-like   .card-rect { fill: #C4F3DB; stroke: #2ed573; }
    .tint-dislike .card-rect { fill: #FFCECF; stroke: #ff4757; }
    .tint-match  .card-rect { fill: #fe80a2; fill-opacity: 0.3; stroke: #fe80a2; }

    /* Motion (rotate + slide + fade) */
    .swipe-anim { transition: transform 0.4s ease, opacity 0.4s ease; }
    .swipe-anim.fade-out { opacity: 0; }
    .swipe-anim.left-tilt  { transform: translate(-40px, -10px) rotate(-30deg); }
    .swipe-anim.right-tilt { transform: translate( 40px, -10px) rotate( 30deg); }
    .swipe-anim.instant { transition: none !important; }

    /* Typing headline */
    #typed-container {
      display: inline-block;
      background: #ff6b81;
      padding: 2px 6px;
      border-radius: 4px;
      text-align: left;
    }
    #typed-word {
      color: white;
      font-weight: 700; 
      white-space: nowrap;
      text-align: left;
      border-right: 2px solid white; /* caret */
      /* Blink for ~5.4s, then disappear */
      animation:
        caret-blink 0.9s steps(1) 6,
        caret-disappear .25s linear 5.4s forwards;
    }
    @keyframes caret-blink { 50% { border-color: transparent; } }
    @keyframes caret-disappear { to { border-color: transparent; } }

    .text-block p {
      font-size: 24px;
      margin: 0;
    }
    .text-block .subheading { 
      font-size: 28px;
      line-height: 1.6; 
    }

    /* Subheading */
    .subheading{
      text-align: center;
      margin: 0;
      padding: 0;
      color: #8f304e;
      line-height: 1.3; /* Tighter line height */
      font-weight: 500;
      font-size: clamp(18px, 2vw + 1vh, 24px);
    }
    .subheading.show{
      opacity: 1;                    /* Keep visible */
      transform: translateY(0);
    }

    .highlight-box {
      display: inline-block;
      background: #fff;
      color: #8f304e;
      font-weight: 700;
      border-radius: 4px;
      padding: 1px 6px;
      margin: 0 2px;
      box-shadow: 0 1px 4px rgba(0,0,0,0.04);
      font-size: 1em; /* Match parent font size */
      line-height: 1.2;
    }

    /* Invisible sentinel used to trigger re-runs on scroll */
    #retrigger-sentinel {
      position: relative;
      width: 100%;
      height: 1px;
      margin-top: 4px;
    }
  </style>
</head>
<body>
  <div class="viz-scale-wrapper">
    <div class="viz-root">
      <div class="wrap" style="width: 100%; height: 100%; display: flex; flex-direction: column;">
        <!-- Sentinel sits just above the headline to reliably enter/leave viewport -->
        <div id="retrigger-sentinel"></div>

        <p id="subheading" class="subheading">
          Female users are <span class="highlight-box">24x likelier</span> to match with someone (i.e. get a like back).
        </p>

        <div id="container">
          <svg id="visualization"></svg>
        </div>
      </div>
    </div>
  </div>

  <script>
    // ---- UNIFORM SCALING FOR THE WHOLE VIZ ------------------------------------
    // Aspect ratio matches card: 1600/910 = 1.758241758...
    const BASE_WIDTH = 1200;
    const BASE_HEIGHT = 682.5; // 1200 / (1600/910) = 682.5 to match exact card aspect ratio
    const wrapper = document.querySelector(".viz-scale-wrapper");
    const root = document.querySelector(".viz-root");

    function resizeViz(){
      if (!wrapper || !root) return;
      const rect = wrapper.getBoundingClientRect();
      const scaleX = rect.width / BASE_WIDTH;
      const scaleY = rect.height / BASE_HEIGHT;
      const scale = Math.min(scaleX, scaleY);
      
      // Get subheading height to position visualization below it
      const subheading = document.getElementById('subheading');
      const subheadingHeight = subheading ? subheading.getBoundingClientRect().height : 0;
      const subheadingPadding = 24; // padding from subheading div
      const topOffset = subheadingHeight + subheadingPadding;
      
      // Position absolutely, horizontally centered, but vertically positioned to start below subheading
      root.style.position = 'absolute';
      root.style.left = '50%';
      root.style.top = `${topOffset}px`;
      root.style.transform = `translateX(-50%) scale(${scale * 1.2})`;
      root.style.transformOrigin = 'top center';
    }

    // Resize on load + whenever parent card changes size
    if (typeof ResizeObserver !== "undefined") {
      const resizeObserver = new ResizeObserver(resizeViz);
      if (wrapper) resizeObserver.observe(wrapper);
    }
    window.addEventListener('resize', resizeViz);
    resizeViz();

    // -------------------- Globals & helpers --------------------
    let vizTimers = [];
    function clearVizTimers(){ vizTimers.forEach(id => clearTimeout(id)); vizTimers = []; }

    // Debounced restart so multiple triggers (DOMContentLoaded, pageshow, IO) don't overlap.
    let restartTimer = null;
    function scheduleRestart(reason = '') {
      if (restartTimer) clearTimeout(restartTimer);
      restartTimer = setTimeout(() => {
        restartTimer = null;
        restartExperience();
      }, 60);
    }

    // Fire a custom event when the subheading becomes visible
    const SUBHEADING_EVENT = 'subheadingShown';

    // Re-usable typing routine. Calls back when done.
    function runTyping(onDone){
      const word = "Gender";
      const el   = document.getElementById("typed-word");
      const box  = document.getElementById("typed-container");
      const speedMs = 110;

      // Reset text & caret animations
      el.textContent = "";
      // Re-trigger caret animations by forcing style recalculation
      el.style.animation = 'none';
      requestAnimationFrame(() => { el.style.animation = ''; });

      // Wait for Inter font so measurement is accurate
      (document.fonts && document.fonts.ready ? document.fonts.ready : Promise.resolve()).then(() => {
        // Measure final width with same computed styles
        const measurer = document.createElement('span');
        const cs = getComputedStyle(el);
        Object.assign(measurer.style, {
          position: 'absolute',
          visibility: 'hidden',
          whiteSpace: 'nowrap',
          fontFamily: cs.fontFamily,
          fontSize: cs.fontSize,
          fontWeight: cs.fontWeight,
          letterSpacing: cs.letterSpacing,
        });
        measurer.textContent = word;
        document.body.appendChild(measurer);
        const textW = Math.ceil(measurer.getBoundingClientRect().width);
        measurer.remove();

        // Fix box size so headline doesn't shift while typing
        const caretW = 2, safety = 2;
        box.style.width = (textW + caretW + safety) + 'px';
        box.style.height = Math.ceil(parseFloat(cs.lineHeight || cs.fontSize)) + 'px';

        // Type it
        let i = 0;
        (function typeNext(){
          if(i <= word.length){
            el.textContent = word.slice(0, i++);
            setTimeout(typeNext, speedMs);
          } else {
            // Reveal subheading on next frame
            const sub = document.getElementById('subheading');
            sub.classList.remove('show'); // clear from previous runs
            requestAnimationFrame(() => {
              sub.classList.add('show');
              document.dispatchEvent(new CustomEvent(SUBHEADING_EVENT));
              if (onDone) onDone();
            });
          }
        })();
      });
    }

    // -------------------- Visualization --------------------
    function initializeViz(data){
      // Use base logical dimensions instead of window dimensions
      const width = BASE_WIDTH;
      const height = BASE_HEIGHT;
      const svg = d3.select('#visualization')
        .attr('width', width)
        .attr('height', height)
        .attr('viewBox', `0 0 ${width} ${height}`)
        .attr('preserveAspectRatio', 'xMidYMid meet')
        .style('overflow', 'visible');


      const fifthWidth = width / 5;
      const femaleX = fifthWidth * 1.0;  // Closer to center, larger left margin
      const maleX   = fifthWidth * 4.0;  // Closer to center, larger right margin
      const dotsCenterX = width / 2;     // Center for dots


      function createDotGrid(parent, x, y, count, dotClass, cols = 8) {
        const dotSize = 8, spacing = 14;
        for (let i = 0; i < count; i++) {
          const row = Math.floor(i / cols), col = i % cols;
          parent.append('circle')
            .attr('class', `dot ${dotClass}`)
            .attr('cx', x + col * spacing)
            .attr('cy', y + row * spacing)
            .attr('r', dotSize / 2);
        }
      }

      /* =================== FEMALE SIDE =================== */
      const femaleG = svg.append('g').attr('transform', `translate(${femaleX - 100}, 40)`);
      femaleG.append('text').attr('class','gender-label').attr('x',100).attr('y', 0).attr('text-anchor','middle').text('FEMALE');

      // iPhone
      femaleG.append('rect').attr('class','phone phone-female').attr('x',0).attr('y',20).attr('width',200).attr('height',380).attr('rx',25);
      femaleG.append('rect').attr('class','screen').attr('x',20).attr('y',50).attr('width',160).attr('height',240).attr('rx',10).attr('fill','#fff5f7').attr('stroke','#8f304e');

      // Profile photo area (larger, more prominent) - pink themed
      femaleG.append('rect').attr('x',20).attr('y',50).attr('width',160).attr('height',140).attr('rx',10).attr('fill','#f3d7de');
      femaleG.append('image')
        .attr('class','profile-circle')
        .attr('href', 'data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'%23a34b65\'%3E%3Cpath d=\'M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z\'/%3E%3C/svg%3E')
        .attr('x', 60)
        .attr('y', 70)
        .attr('width', 80)
        .attr('height', 80);

      // Name and age - pink themed
      femaleG.append('rect').attr('class','text-placeholder name').attr('x',30).attr('y',200).attr('width',100).attr('height',14).attr('rx',3).attr('fill','#8f304e');
      femaleG.append('rect').attr('x',135).attr('y',200).attr('width',40).attr('height',14).attr('rx',3).attr('fill','#a34b65');
      
      // Location/distance - pink themed
      femaleG.append('circle').attr('cx',30).attr('cy',220).attr('r',4).attr('fill','#a34b65');
      femaleG.append('rect').attr('class','text-placeholder').attr('x',38).attr('y',216).attr('width',60).attr('height',8).attr('rx',2).attr('fill','#a34b65');
      
      // Bio text lines - pink themed
      femaleG.append('rect').attr('class','text-placeholder').attr('x',30).attr('y',235).attr('width',130).attr('height',7).attr('rx',2).attr('fill','#edbacb');
      femaleG.append('rect').attr('class','text-placeholder').attr('x',30).attr('y',245).attr('width',120).attr('height',7).attr('rx',2).attr('fill','#edbacb');
      femaleG.append('rect').attr('class','text-placeholder').attr('x',30).attr('y',255).attr('width',100).attr('height',7).attr('rx',2).attr('fill','#edbacb');

      femaleG.append('circle').attr('class','button dislike-btn').attr('cx',60).attr('cy',330).attr('r',25);
      femaleG.append('line').attr('class','button dislike-btn').attr('x1',50).attr('y1',320).attr('x2',70).attr('y2',340);
      femaleG.append('line').attr('class','button dislike-btn').attr('x1',70).attr('y1',320).attr('x2',50).attr('y2',340);

      femaleG.append('circle').attr('class','button like-btn').attr('cx',140).attr('cy',330).attr('r',25);
      femaleG.append('path').attr('class','button like-btn')
        .attr('d','M 140,330 C 140,327 137,323 133,323 C 130,323 128,325 128,328 C 128,332 140,340 140,340 C 140,340 152,332 152,328 C 152,325 150,323 147,323 C 143,323 140,327 140,330 Z')
        .attr('fill','none');

      const femaleSwipeCard = femaleG
        .insert('g', '.button')
        .attr('class','swipe-card swipe-anim')
        .attr('transform','translate(0,0)');
      femaleSwipeCard.append('rect').attr('class','card-rect').attr('x',20).attr('y',50).attr('width',160).attr('height',240).attr('rx',10).attr('fill','#fff5f7');
      
      // Profile photo area - pink themed
      femaleSwipeCard.append('rect').attr('x',20).attr('y',50).attr('width',160).attr('height',140).attr('rx',10).attr('fill','#f3d7de');
      femaleSwipeCard.append('image')
        .attr('class','card-avatar')
        .attr('href', 'data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'%23a34b65\'%3E%3Cpath d=\'M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z\'/%3E%3C/svg%3E')
        .attr('x', 60)
        .attr('y', 70)
        .attr('width', 80)
        .attr('height', 80);
      
      // Name and age - pink themed
      femaleSwipeCard.append('rect').attr('class','text-placeholder name').attr('x',30).attr('y',200).attr('width',100).attr('height',14).attr('rx',3).attr('fill','#8f304e');
      femaleSwipeCard.append('rect').attr('x',135).attr('y',200).attr('width',40).attr('height',14).attr('rx',3).attr('fill','#a34b65');
      
      // Location/distance - pink themed
      femaleSwipeCard.append('circle').attr('cx',30).attr('cy',220).attr('r',4).attr('fill','#a34b65');
      femaleSwipeCard.append('rect').attr('x',38).attr('y',216).attr('width',60).attr('height',8).attr('rx',2).attr('fill','#a34b65');
      
      // Bio text lines - pink themed
      femaleSwipeCard.append('rect').attr('x',30).attr('y',235).attr('width',130).attr('height',7).attr('rx',2).attr('fill','#edbacb');
      femaleSwipeCard.append('rect').attr('x',30).attr('y',245).attr('width',120).attr('height',7).attr('rx',2).attr('fill','#edbacb');
      femaleSwipeCard.append('rect').attr('x',30).attr('y',255).attr('width',100).attr('height',7).attr('rx',2).attr('fill','#edbacb');

      // Layout numbers
      const dotSpacing = 14, dotsWidth = 7 * dotSpacing;
      const femaleMatchesRows = Math.ceil(data.female.matches / 8);
      const femaleLikesRows   = Math.ceil(data.female.likes / 8);
      const femaleDislikesRows= Math.ceil(data.female.dislikes / 8);
      const maleMatchesRows   = Math.ceil(data.male.matches / 8);
      const maleLikesRows     = Math.ceil(data.male.likes / 8);
      const maleDislikesRows  = Math.ceil(data.male.dislikes / 8);

      const femaleMatchesHeight = femaleMatchesRows * dotSpacing;
      const femaleLikesHeight   = femaleLikesRows * dotSpacing;
      const femaleDislikesHeight= femaleDislikesRows * dotSpacing;
      const maleMatchesHeight   = maleMatchesRows * dotSpacing;
      const maleLikesHeight     = maleLikesRows * dotSpacing;
      const maleDislikesHeight  = maleDislikesRows * dotSpacing;

      const lastDislikesRowY = 365;  // Moved down by 20px
      const sectionGap = 28;
      const labelGap = 10;

      const femaleDislikesDotY = lastDislikesRowY - (femaleDislikesRows - 1) * dotSpacing;
      const maleDislikesDotY   = lastDislikesRowY - (maleDislikesRows   - 1) * dotSpacing;

      const femaleLikesDotY   = femaleDislikesDotY - femaleLikesHeight   - sectionGap;
      const femaleMatchesDotY = femaleLikesDotY    - femaleMatchesHeight - sectionGap;

      const maleLikesDotY     = maleDislikesDotY   - maleLikesHeight     - sectionGap;
      const maleMatchesDotY   = maleLikesDotY      - maleMatchesHeight   - sectionGap;

      // Add title above dots (constrained width to avoid phone overlap)
      const titleWidth = Math.min(400, width * 0.4);  // Max 400px or 40% of width, whichever is smaller
      const titleForeign = svg.append('foreignObject')
        .attr('x', dotsCenterX - titleWidth / 2)
        .attr('y', 45)
        .attr('width', titleWidth)
        .attr('height', 50);
      titleForeign.append('xhtml:div')
        .style('text-align', 'center')
        .style('font-size', '16px')
        .style('font-weight', '500')
        .style('color', '#8f304e')
        .style('font-family', '"Inter", system-ui, -apple-system, Segoe UI, Roboto, sans-serif')
        .style('line-height', '1.4')
        .text('On average, this is the number of swipes and matches per day:');

      // Create separate group for female dots in the middle
      const femaleDotsG = svg.append('g').attr('transform', `translate(${dotsCenterX - 150}, 110)`);
      const femaleDotsX = 0;
      const femaleLabelX = femaleDotsX;

      femaleDotsG.append('text')
        .attr('class','label')
        .attr('x', femaleLabelX - 5)
        .attr('y', femaleMatchesDotY - labelGap)
        .attr('text-anchor','start')
        .style('font-size', '13px')
        .text(`Gets ${data.female.matches} Matches`);
      createDotGrid(femaleDotsG, femaleDotsX, femaleMatchesDotY, data.female.matches, 'matches', 8);

      femaleDotsG.append('text')
        .attr('class','label')
        .attr('x', femaleLabelX - 5)
        .attr('y', femaleLikesDotY - labelGap)
        .attr('text-anchor','start')
        .style('font-size', '13px')
        .text(`Gives ${data.female.likes} Likes`);
      createDotGrid(femaleDotsG, femaleDotsX, femaleLikesDotY, data.female.likes, 'likes', 8);

      femaleDotsG.append('text')
        .attr('class','label')
        .attr('x', femaleLabelX - 5)
        .attr('y', femaleDislikesDotY - labelGap)
        .attr('text-anchor','start')
        .style('font-size', '13px')
        .text(`Gives ${data.female.dislikes} Dislikes`);
      createDotGrid(femaleDotsG, femaleDotsX, femaleDislikesDotY, data.female.dislikes, 'dislikes', 8);

        // Hand starts at swiping Y position
        const handY = 205, centerX = 0;
        const femaleHand = femaleG.append('g').attr('class','hand-group').attr('transform', `translate(${centerX}, ${handY})`);
        femaleHand.append('image')
          .attr('href', '../images/femalehand.png')
          .attr('x', -40)
          .attr('y', 30)
          .attr('width', 270)
          .attr('height', 405)
          .attr('preserveAspectRatio', 'xMidYMid meet');

      /* =================== MALE SIDE =================== */
      const maleG = svg.append('g').attr('transform', `translate(${maleX - 100}, 40)`);
      maleG.append('text').attr('class','gender-label').attr('x',110).attr('y',0).attr('text-anchor','middle').text('MALE');

      // iPhone
      maleG.append('rect').attr('class','phone phone-male').attr('x',15).attr('y',20).attr('width',200).attr('height',380).attr('rx',25);
      maleG.append('rect').attr('class','screen').attr('x',35).attr('y',50).attr('width',160).attr('height',240).attr('rx',10).attr('fill','#fff5f7').attr('stroke','#7d4b88');

      // Profile photo area (larger, more prominent) - pink themed
      maleG.append('rect').attr('x',35).attr('y',50).attr('width',160).attr('height',140).attr('rx',10).attr('fill','#f3d7de');
      maleG.append('image')
        .attr('class','profile-circle')
        .attr('href', 'data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'%23a34b65\'%3E%3Cpath d=\'M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z\'/%3E%3C/svg%3E')
        .attr('x', 75)
        .attr('y', 70)
        .attr('width', 80)
        .attr('height', 80);

      // Name and age - pink themed
      maleG.append('rect').attr('class','text-placeholder name').attr('x',45).attr('y',200).attr('width',100).attr('height',14).attr('rx',3).attr('fill','#8f304e');
      maleG.append('rect').attr('x',150).attr('y',200).attr('width',40).attr('height',14).attr('rx',3).attr('fill','#a34b65');
      
      // Location/distance - pink themed
      maleG.append('circle').attr('cx',45).attr('cy',220).attr('r',4).attr('fill','#a34b65');
      maleG.append('rect').attr('class','text-placeholder').attr('x',53).attr('y',216).attr('width',60).attr('height',8).attr('rx',2).attr('fill','#a34b65');
      
      // Bio text lines - pink themed
      maleG.append('rect').attr('class','text-placeholder').attr('x',45).attr('y',235).attr('width',130).attr('height',7).attr('rx',2).attr('fill','#edbacb');
      maleG.append('rect').attr('class','text-placeholder').attr('x',45).attr('y',245).attr('width',120).attr('height',7).attr('rx',2).attr('fill','#edbacb');
      maleG.append('rect').attr('class','text-placeholder').attr('x',45).attr('y',255).attr('width',100).attr('height',7).attr('rx',2).attr('fill','#edbacb');

      maleG.append('circle').attr('class','button dislike-btn').attr('cx',75).attr('cy',330).attr('r',25);
      maleG.append('line').attr('class','button dislike-btn').attr('x1',65).attr('y1',320).attr('x2',85).attr('y2',340);
      maleG.append('line').attr('class','button dislike-btn').attr('x1',85).attr('y1',320).attr('x2',65).attr('y2',340);

      maleG.append('circle').attr('class','button like-btn male-like').attr('cx',155).attr('cy',330).attr('r',25);
      maleG.append('path').attr('class','button like-btn male-like')
        .attr('d','M 155,330 C 155,327 152,323 148,323 C 145,323 143,325 143,328 C 143,332 155,340 155,340 C 155,340 167,332 167,328 C 167,325 165,323 162,323 C 158,323 155,327 155,330 Z')
        .attr('fill','none');

      const maleSwipeCard = maleG
        .insert('g', '.button')
        .attr('class','swipe-card swipe-anim')
        .attr('transform','translate(0,0)');
      maleSwipeCard.append('rect').attr('class','card-rect').attr('x',35).attr('y',50).attr('width',160).attr('height',240).attr('rx',10).attr('fill','#fff5f7');
      
      // Profile photo area - pink themed
      maleSwipeCard.append('rect').attr('x',35).attr('y',50).attr('width',160).attr('height',140).attr('rx',10).attr('fill','#f3d7de');
      maleSwipeCard.append('image')
        .attr('class','card-avatar')
        .attr('href', 'data:image/svg+xml,%3Csvg xmlns=\'http://www.w3.org/2000/svg\' viewBox=\'0 0 24 24\' fill=\'%23a34b65\'%3E%3Cpath d=\'M12 12c2.21 0 4-1.79 4-4s-1.79-4-4-4-4 1.79-4 4 1.79 4 4 4zm0 2c-2.67 0-8 1.34-8 4v2h16v-2c0-2.66-5.33-4-8-4z\'/%3E%3C/svg%3E')
        .attr('x', 75)
        .attr('y', 70)
        .attr('width', 80)
        .attr('height', 80);
      
      // Name and age - pink themed
      maleSwipeCard.append('rect').attr('class','text-placeholder name').attr('x',45).attr('y',200).attr('width',100).attr('height',14).attr('rx',3).attr('fill','#8f304e');
      maleSwipeCard.append('rect').attr('x',150).attr('y',200).attr('width',40).attr('height',14).attr('rx',3).attr('fill','#a34b65');
      
      // Location/distance - pink themed
      maleSwipeCard.append('circle').attr('cx',45).attr('cy',220).attr('r',4).attr('fill','#a34b65');
      maleSwipeCard.append('rect').attr('x',53).attr('y',216).attr('width',60).attr('height',8).attr('rx',2).attr('fill','#a34b65');
      
      // Bio text lines - pink themed
      maleSwipeCard.append('rect').attr('x',45).attr('y',235).attr('width',130).attr('height',7).attr('rx',2).attr('fill','#edbacb');
      maleSwipeCard.append('rect').attr('x',45).attr('y',245).attr('width',120).attr('height',7).attr('rx',2).attr('fill','#edbacb');
      maleSwipeCard.append('rect').attr('x',45).attr('y',255).attr('width',100).attr('height',7).attr('rx',2).attr('fill','#edbacb');

      // Add vertical divider line between the two dot groups
      const dividerYStart = 110;  // Start below the title (title ends around y=100)
      const dividerYEnd = height - 20;  // Extend to bottom of card with small margin
      svg.append('line')
        .attr('x1', dotsCenterX)
        .attr('y1', dividerYStart)
        .attr('x2', dotsCenterX)
        .attr('y2', dividerYEnd)
        .attr('stroke', '#e8d0d8')
        .attr('stroke-width', 1.5)
        .attr('opacity', 0.8);

      // Create separate group for male dots in the middle
      const maleDotsG = svg.append('g').attr('transform', `translate(${dotsCenterX + 50}, 110)`);
      const maleDotsX = 0;
      const maleLabelX = maleDotsX;

      maleDotsG.append('text')
        .attr('class','label')
        .attr('x', maleLabelX - 5)
        .attr('y', maleMatchesDotY - labelGap)
        .attr('text-anchor','start')
        .style('font-size', '13px')
        .text(`Gets ${data.male.matches} Match`);
      createDotGrid(maleDotsG, maleDotsX, maleMatchesDotY, data.male.matches, 'matches', 8);

      maleDotsG.append('text')
        .attr('class','label')
        .attr('x', maleLabelX - 5)
        .attr('y', maleLikesDotY - labelGap)
        .attr('text-anchor','start')
        .style('font-size', '13px')
        .text(`Gives ${data.male.likes} Likes`);
      createDotGrid(maleDotsG, maleDotsX, maleLikesDotY, data.male.likes, 'likes', 8);

      maleDotsG.append('text')
        .attr('class','label')
        .attr('x', maleLabelX - 5)
        .attr('y', maleDislikesDotY - labelGap)
        .attr('text-anchor','start')
        .style('font-size', '13px')
        .text(`Gives ${data.male.dislikes} Dislikes`);
      createDotGrid(maleDotsG, maleDotsX, maleDislikesDotY, data.male.dislikes, 'dislikes', 8);

        const maleHand = maleG.append('g').attr('class','hand-group').attr('transform', `translate(${centerX}, ${handY})`);
        maleHand.append('image')
          .attr('href', '../images/malehand.png')
          .attr('x', -5)
          .attr('y', -50)
          .attr('width', 375)
          .attr('height', 562.5)
          .attr('preserveAspectRatio', 'xMidYMid meet');


      /* ===== Helpers: match timing + force-pink for BOTH cards ===== */
      const TINTS = { like:'tint-like', dislike:'tint-dislike', match:'tint-match' };
      let lastRightSwipeAt = { female: 0, male: 0 };

      function registerRightSwipe(side, windowMs = 800) {
        const now = Date.now();
        const other = side === 'female' ? 'male' : 'female';
        const isMatch = (now - lastRightSwipeAt[other]) <= windowMs;
        lastRightSwipeAt[side] = now;
        return isMatch;
      }
      function forceMatchTint(cardG) {
        cardG.classed(TINTS.like, false).classed(TINTS.dislike, false).classed(TINTS.match, true);
      }
      function onMatchBoth() {
        forceMatchTint(femaleSwipeCard);
        forceMatchTint(maleSwipeCard);
      }

      function animateSwipeCard(cardG, dir, useMatchTint = false, onDone = () => {}) {
        cardG.classed(TINTS.like, false)
             .classed(TINTS.dislike, false)
             .classed(TINTS.match, false)
             .classed('left-tilt', false)
             .classed('right-tilt', false)
             .classed('fade-out', false);

        if (useMatchTint) cardG.classed(TINTS.match, true);
        else cardG.classed(dir === 'right' ? TINTS.like : TINTS.dislike, true);

        cardG.classed(dir === 'right' ? 'right-tilt' : 'left-tilt', true)
             .classed('fade-out', true);

        const t = setTimeout(() => {
          cardG.classed('instant', true)
               .classed('left-tilt', false)
               .classed('right-tilt', false)
               .classed('fade-out', false)
               .classed(TINTS.like, false)
               .classed(TINTS.dislike, false)
               .classed(TINTS.match, false);
          try { cardG.node().getBBox(); } catch(e) {}
          requestAnimationFrame(() => {
            cardG.classed('instant', false);
            onDone();
          });
        }, 427);
        vizTimers.push(t);
      }

      function animateHand(handGroup, dislikeElements, likeElements, datum, options = {}) {
        const { cardG, side } = options;
        const handY = 205, centerX = 0, leftX = -40, rightX = 40;
        const totalSwipes = datum.likes + datum.matches + datum.dislikes;
        const likeProbability = (datum.likes + datum.matches) / totalSwipes;

        handGroup.attr('transform', `translate(${centerX}, ${handY})`);

        function swipeLeft() {
          dislikeElements.classed('pressed', true);
          if (cardG) animateSwipeCard(cardG, 'left', false);
          handGroup.transition().duration(400).attr('transform', `translate(${leftX}, ${handY})`)
              .on('end', () => {
                const t1 = setTimeout(() => {
                  dislikeElements.classed('pressed', false);
                  handGroup.transition().duration(400).attr('transform', `translate(${centerX}, ${handY})`)
                    .on('end', () => {
                      const t2 = setTimeout(performSwipe, 200);
                      vizTimers.push(t2);
                    });
                }, 133);
                vizTimers.push(t1);
              });
        }

        function swipeRight() {
          likeElements.classed('pressed', true);
          const isMatch = side ? registerRightSwipe(side) : false;
          if (isMatch) onMatchBoth();
          if (cardG) animateSwipeCard(cardG, 'right', isMatch);
          handGroup.transition().duration(400).attr('transform', `translate(${rightX}, ${handY})`)
              .on('end', () => {
                const t3 = setTimeout(() => {
                  likeElements.classed('pressed', false);
                  handGroup.transition().duration(400).attr('transform', `translate(${centerX}, ${handY})`)
                    .on('end', () => {
                      const t4 = setTimeout(performSwipe, 200);
                      vizTimers.push(t4);
                    });
                }, 133);
                vizTimers.push(t3);
              });
        }

        function performSwipe() {
          if (Math.random() >= likeProbability) swipeLeft();
          else swipeRight();
        }

        const t5 = setTimeout(performSwipe, 1000);
        vizTimers.push(t5);
      }

      // Button refs
      const femaleDislikeElements = femaleG.selectAll('.dislike-btn');
      const femaleLikeElements = femaleG.selectAll('.like-btn').filter(function(){ return !this.classList.contains('male-like'); });
      const maleDislikeElements   = maleG.selectAll('.dislike-btn');
      const maleLikeElements      = maleG.selectAll('.like-btn');

      // Start ANY hand animations only after the subheading is shown
      const startAnimations = (() => {
        let ran = false;
        return () => {
          if (ran) return;
          ran = true;
          animateHand(femaleHand, femaleDislikeElements, femaleLikeElements, data.female, { cardG: femaleSwipeCard, side: 'female' });
          animateHand(maleHand,   maleDislikeElements,   maleLikeElements,   data.male,   { cardG: maleSwipeCard,   side: 'male'   });
        };
      })();

      // Wire once per initialize
      const startOnSubheading = () => startAnimations();
      document.addEventListener(SUBHEADING_EVENT, startOnSubheading, { once: true });
      // If subheading already visible (rare), start immediately
      if (document.getElementById('subheading')?.classList.contains('show')) startAnimations();
    }

    // -------------------- Data + Restart Orchestration --------------------
    const defaultData = {
      female: { swipes: 152, likes: 8,  dislikes: 144, matches: 3 },
      male:   { swipes: 120, likes: 64, dislikes: 56,  matches: 1 }
    };
    let currentData = JSON.parse(JSON.stringify(defaultData));

    function resetDOM(){
      // Reset subheading
      const sub = document.getElementById('subheading');
      sub.classList.remove('show');
      // Reset SVG
      d3.select('#visualization').selectAll('*').remove();
    }

    function restartExperience(){
      clearVizTimers();
      resetDOM();
      // (Re)load CSV if present; else run with defaults
      d3.csv("../data/swipedata.csv").then(csvData => {
        const femaleRow = csvData.find(row => row.Gender?.toLowerCase() === 'female');
        const maleRow   = csvData.find(row => row.Gender?.toLowerCase() === 'male');
        currentData = JSON.parse(JSON.stringify(defaultData));
        if (femaleRow) {
          currentData.female = {
            swipes: +femaleRow.swipes || 0,
            likes: +femaleRow.likes || 0,
            dislikes: +femaleRow.dislikes || 0,
            matches: +femaleRow.matches || 0
          };
        }
        if (maleRow) {
          currentData.male = {
            swipes: +maleRow.swipes || 0,
            likes: +maleRow.likes || 0,
            dislikes: +maleRow.dislikes || 0,
            matches: +maleRow.matches || 0
          };
        }
        initializeViz(currentData);
        // Show subheading immediately (no typing effect)
        const sub = document.getElementById('subheading');
        sub.classList.remove('show');
        requestAnimationFrame(() => {
          sub.classList.add('show');
          document.dispatchEvent(new CustomEvent(SUBHEADING_EVENT));
        });
      }).catch(() => {
        currentData = JSON.parse(JSON.stringify(defaultData));
        initializeViz(currentData);
        // Show subheading immediately (no typing effect)
        const sub = document.getElementById('subheading');
        sub.classList.remove('show');
        requestAnimationFrame(() => {
          sub.classList.add('show');
          document.dispatchEvent(new CustomEvent(SUBHEADING_EVENT));
        });
      });
    }

    // -------------------- Boot + Visibility / Scroll triggers --------------------
    document.addEventListener('DOMContentLoaded', () => {
      // Initial start (debounced)
      scheduleRestart('domready');

      // If tab becomes visible again, restart (debounced)
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible') scheduleRestart('visible');
      });

      // BFCache restore only â€” avoid double fire on initial load
      window.addEventListener('pageshow', (e) => {
        if (e.persisted) scheduleRestart('pageshow-bfcache');
      });

      // Re-run when the top sentinel enters the viewport (debounced)
      const sentinel = document.getElementById('retrigger-sentinel');
      if (sentinel && 'IntersectionObserver' in window) {
        let lastFire = Date.now();        // cooldown starts now so first paint doesn't trigger
        const MIN_GAP = 1200;             // ms
        const io = new IntersectionObserver(entries => {
          entries.forEach(entry => {
            if (entry.isIntersecting) {
              const now = Date.now();
              if (now - lastFire > MIN_GAP) {
                lastFire = now;
                scheduleRestart('io');
              }
            }
          });
        }, { threshold: 0, rootMargin: '0px 0px -20% 0px' });
        io.observe(sentinel);
      }
    });
  </script>
</body>
</html>
